{% extends "base.html" %}

{% block title %}테트리스 - MBTI & Arcade Web Service{% endblock %}

{% block head %}
<style>
    #gameCanvas {
        border: 2px solid #333;
        background: #000;
    }
    .game-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
    }
    .game-info {
        display: flex;
        gap: 20px;
        font-size: 1.2em;
        font-weight: bold;
    }
    .controls {
        background: #f8f9fa;
        padding: 15px;
        border-radius: 8px;
        text-align: center;
    }
</style>
{% endblock %}

{% block content %}
<div class="game-container">
    <h1 class="text-3xl font-bold text-gray-800 mb-4">🧩 테트리스</h1>
    
    <div class="game-info">
        <div>점수: <span id="score">0</span></div>
        <div>레벨: <span id="level">1</span></div>
        <div>라인: <span id="lines">0</span></div>
    </div>
    
    <canvas id="gameCanvas" width="300" height="600"></canvas>
    
    <div class="controls">
        <p class="text-gray-600 mb-2">조작법: 방향키 (←→↓), 스페이스바 (회전)</p>
        <button id="startBtn" class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors">
            게임 시작
        </button>
        <button id="pauseBtn" class="bg-yellow-600 text-white px-6 py-2 rounded-lg hover:bg-yellow-700 transition-colors ml-2">
            일시정지
        </button>
    </div>
    
    <div class="mt-4">
        <a href="/arcade" class="text-blue-600 hover:text-blue-800 underline">
            ← 아케이드로 돌아가기
        </a>
    </div>
</div>

<script>
class TetrisGame {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.blockSize = 30;
        this.cols = 10;
        this.rows = 20;
        this.board = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
        this.score = 0;
        this.level = 1;
        this.lines = 0;
        this.gameRunning = false;
        this.gameLoop = null;
        
        this.currentPiece = null;
        this.pieces = [
            [[1,1,1,1]], // I
            [[1,1],[1,1]], // O
            [[1,1,1],[0,1,0]], // T
            [[1,1,1],[1,0,0]], // L
            [[1,1,1],[0,0,1]], // J
            [[1,1,0],[0,1,1]], // S
            [[0,1,1],[1,1,0]]  // Z
        ];
        this.colors = ['#00f0f0', '#f0f000', '#a000f0', '#f0a000', '#0000f0', '#00f000', '#f00000'];
        
        this.init();
    }
    
    init() {
        this.bindEvents();
        this.draw();
    }
    
    bindEvents() {
        document.addEventListener('keydown', (e) => {
            if (!this.gameRunning || !this.currentPiece) return;
            
            switch(e.key) {
                case 'ArrowLeft':
                    this.movePiece(-1, 0);
                    break;
                case 'ArrowRight':
                    this.movePiece(1, 0);
                    break;
                case 'ArrowDown':
                    this.movePiece(0, 1);
                    break;
                case ' ':
                    this.rotatePiece();
                    break;
            }
        });
        
        document.getElementById('startBtn').addEventListener('click', () => this.startGame());
        document.getElementById('pauseBtn').addEventListener('click', () => this.togglePause());
    }
    
    createPiece() {
        const pieceIndex = Math.floor(Math.random() * this.pieces.length);
        return {
            shape: this.pieces[pieceIndex],
            color: this.colors[pieceIndex],
            x: Math.floor(this.cols / 2) - Math.floor(this.pieces[pieceIndex][0].length / 2),
            y: 0
        };
    }
    
    startGame() {
        if (this.gameRunning) return;
        
        this.board = Array(this.rows).fill().map(() => Array(this.cols).fill(0));
        this.score = 0;
        this.level = 1;
        this.lines = 0;
        this.gameRunning = true;
        this.currentPiece = this.createPiece();
        
        document.getElementById('score').textContent = this.score;
        document.getElementById('level').textContent = this.level;
        document.getElementById('lines').textContent = this.lines;
        document.getElementById('startBtn').textContent = '다시 시작';
        
        this.gameLoop = setInterval(() => this.update(), 1000 - (this.level - 1) * 50);
    }
    
    togglePause() {
        if (!this.gameRunning) return;
        
        if (this.gameLoop) {
            clearInterval(this.gameLoop);
            this.gameLoop = null;
            document.getElementById('pauseBtn').textContent = '계속하기';
        } else {
            this.gameLoop = setInterval(() => this.update(), 1000 - (this.level - 1) * 50);
            document.getElementById('pauseBtn').textContent = '일시정지';
        }
    }
    
    movePiece(dx, dy) {
        const newX = this.currentPiece.x + dx;
        const newY = this.currentPiece.y + dy;
        
        if (this.isValidMove(this.currentPiece.shape, newX, newY)) {
            this.currentPiece.x = newX;
            this.currentPiece.y = newY;
            this.draw();
            return true;
        }
        return false;
    }
    
    rotatePiece() {
        const rotated = this.currentPiece.shape[0].map((_, i) => 
            this.currentPiece.shape.map(row => row[i]).reverse()
        );
        
        if (this.isValidMove(rotated, this.currentPiece.x, this.currentPiece.y)) {
            this.currentPiece.shape = rotated;
            this.draw();
        }
    }
    
    isValidMove(shape, x, y) {
        for (let row = 0; row < shape.length; row++) {
            for (let col = 0; col < shape[row].length; col++) {
                if (shape[row][col]) {
                    const newX = x + col;
                    const newY = y + row;
                    
                    if (newX < 0 || newX >= this.cols || newY >= this.rows) return false;
                    if (newY >= 0 && this.board[newY][newX]) return false;
                }
            }
        }
        return true;
    }
    
    placePiece() {
        for (let row = 0; row < this.currentPiece.shape.length; row++) {
            for (let col = 0; col < this.currentPiece.shape[row].length; col++) {
                if (this.currentPiece.shape[row][col]) {
                    const boardY = this.currentPiece.y + row;
                    const boardX = this.currentPiece.x + col;
                    if (boardY >= 0) {
                        this.board[boardY][boardX] = this.currentPiece.color;
                    }
                }
            }
        }
        
        this.clearLines();
        this.currentPiece = this.createPiece();
        
        if (!this.isValidMove(this.currentPiece.shape, this.currentPiece.x, this.currentPiece.y)) {
            this.gameOver();
        }
    }
    
    clearLines() {
        let linesCleared = 0;
        
        for (let row = this.rows - 1; row >= 0; row--) {
            if (this.board[row].every(cell => cell !== 0)) {
                this.board.splice(row, 1);
                this.board.unshift(Array(this.cols).fill(0));
                linesCleared++;
                row++;
            }
        }
        
        if (linesCleared > 0) {
            this.lines += linesCleared;
            this.score += linesCleared * 100 * this.level;
            
            if (this.lines >= this.level * 10) {
                this.level++;
                clearInterval(this.gameLoop);
                this.gameLoop = setInterval(() => this.update(), 1000 - (this.level - 1) * 50);
            }
            
            document.getElementById('score').textContent = this.score;
            document.getElementById('level').textContent = this.level;
            document.getElementById('lines').textContent = this.lines;
        }
    }
    
    update() {
        if (!this.movePiece(0, 1)) {
            this.placePiece();
        }
        this.draw();
    }
    
    draw() {
        // 보드 그리기
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        
        // 보드의 블록들 그리기
        for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
                if (this.board[row][col]) {
                    this.ctx.fillStyle = this.board[row][col];
                    this.ctx.fillRect(
                        col * this.blockSize,
                        row * this.blockSize,
                        this.blockSize - 1,
                        this.blockSize - 1
                    );
                }
            }
        }
        
        // 현재 조각 그리기
        if (this.currentPiece) {
            this.ctx.fillStyle = this.currentPiece.color;
            for (let row = 0; row < this.currentPiece.shape.length; row++) {
                for (let col = 0; col < this.currentPiece.shape[row].length; col++) {
                    if (this.currentPiece.shape[row][col]) {
                        const x = (this.currentPiece.x + col) * this.blockSize;
                        const y = (this.currentPiece.y + row) * this.blockSize;
                        if (y >= 0) {
                            this.ctx.fillRect(x, y, this.blockSize - 1, this.blockSize - 1);
                        }
                    }
                }
            }
        }
    }
    
    gameOver() {
        this.gameRunning = false;
        clearInterval(this.gameLoop);
        this.gameLoop = null;
        
        alert(`게임 오버! 점수: ${this.score}, 레벨: ${this.level}, 라인: ${this.lines}`);
        document.getElementById('startBtn').textContent = '게임 시작';
        document.getElementById('pauseBtn').textContent = '일시정지';
    }
}

// 게임 시작
new TetrisGame();
</script>
{% endblock %} 